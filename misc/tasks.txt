Глобально:

Получение списка всех видеофайлов, которые есть в БД:
/api/v1/video/collection?limit=50&page=int&search=str&sort=str&sort_order=str
// search — поиск с учётом морфологии по атрибутам фильма (название, описание, режиссёр и т.д.).
// limit — количество элементов в выдаче.
// page — страница в выдаче.
// sort — сортировка по определённому полю.
// sort_order — направление сортировки. 

Получение карточки одного конкретного видеофайла:
/api/v1/video/get/<id:str> 

Получение информации о клиенте:
/client/info 

Стек технологий
    Flask;
    SQLite;
    ETL (SQLite → ElasticSearch);
    Raw SQL (наследие от готовой DB);
    Swagger (описание интерфейсов для работы с клиентом);
    Smoke tests (Postman как интерфейс для тестирования).


БД:

1. Сценаристы (writers) хранятся в разном виде. Когда сценарист один, то появляется просто id этого сценариста. Когда же сценаристов много, то во фронт отдаётся массив записей вида [{"id": "123"}, {"id": "234"}]. Ваш коллега грешит на данные в колонках writer и writers, но у него не доходили руки навести в них порядок, так как он постоянно завален другими задачами по проекту.
2. Поступали жалобы на записи вида 'N/A' вместо обычных null в полях, связанных со сценаристами (writers), актёрами (actors), режиссёрами (directors) и описанием фильмов (plot). Коллеги были бы вам очень признательны, если эти записи в итоге вы замените на null.
3. Также ваш коллега с фронта упомянул, что им приходится самим парсить данные по жанрам (genre) и режиссёрам (directors).

a. Отсутствие ключевых полей primary key у таблицы movie_actors. У вас не будет возможности искать записи, а также есть вероятность вставить дублирующие данные.
b. Денормализованные данные в таблице movies. Для некоторых практических ситуаций это может быть полезно: меньше join-склеек между таблицами. Однако, это усложняет обновление данных, например, если была найдена ошибка в каком-то из популярных жанров.
c. Использование документноориентированной структуры в поле writers. Этот подход часто можно встретить в таких БД как MongoDB или Elasticsearch. SQLite — реляционная БД, поэтому предполагает иную работу с данными.
d. Сценаристы writers связаны с таблицей фильмов как ManyToMany, но без промежуточной таблицы. Это очень усложняет дальнейшую склейку (join) данных, чтобы, например, отправлять их в Elasticsearch.


