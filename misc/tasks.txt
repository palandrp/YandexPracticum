Глобально:

Получение списка всех видеофайлов, которые есть в БД:
/api/v1/video/collection?limit=50&page=int&search=str&sort=str&sort_order=str
// search — поиск с учётом морфологии по атрибутам фильма (название, описание, режиссёр и т.д.).
// limit — количество элементов в выдаче.
// page — страница в выдаче.
// sort — сортировка по определённому полю.
// sort_order — направление сортировки. 

Получение карточки одного конкретного видеофайла:
/api/v1/video/get/<id:str> 

Получение информации о клиенте:
/client/info 

Стек технологий
    Flask;
    SQLite;
    ETL (SQLite → ElasticSearch);
    Raw SQL (наследие от готовой DB);
    Swagger (описание интерфейсов для работы с клиентом);
    Smoke tests (Postman как интерфейс для тестирования).


БД:

1. Сценаристы (writers) хранятся в разном виде. Когда сценарист один, то появляется просто id этого сценариста. Когда же сценаристов много, то во фронт отдаётся массив записей вида [{"id": "123"}, {"id": "234"}]. Ваш коллега грешит на данные в колонках writer и writers, но у него не доходили руки навести в них порядок, так как он постоянно завален другими задачами по проекту.
2. Поступали жалобы на записи вида 'N/A' вместо обычных null в полях, связанных со сценаристами (writers), актёрами (actors), режиссёрами (directors) и описанием фильмов (plot). Коллеги были бы вам очень признательны, если эти записи в итоге вы замените на null.
3. Также ваш коллега с фронта упомянул, что им приходится самим парсить данные по жанрам (genre) и режиссёрам (directors).

a. Отсутствие ключевых полей primary key у таблицы movie_actors. У вас не будет возможности искать записи, а также есть вероятность вставить дублирующие данные.
b. Денормализованные данные в таблице movies. Для некоторых практических ситуаций это может быть полезно: меньше join-склеек между таблицами. Однако, это усложняет обновление данных, например, если была найдена ошибка в каком-то из популярных жанров.
c. Использование документноориентированной структуры в поле writers. Этот подход часто можно встретить в таких БД как MongoDB или Elasticsearch. SQLite — реляционная БД, поэтому предполагает иную работу с данными.
d. Сценаристы writers связаны с таблицей фильмов как ManyToMany, но без промежуточной таблицы. Это очень усложняет дальнейшую склейку (join) данных, чтобы, например, отправлять их в Elasticsearch.


БД -> Elastic:

Реализуйте ETL-механизм загрузки фильмов из SQLite в Elasticsearch.
Основная задача — написать SQL-запрос в SQLite для получения фильмов и всех связанных сущностей, затем трансформировать данные и загрузить их в индекс movies в Elasticsearch.

Схема достаточно простая, но стоит сразу обозначить точки, где могут возникнуть проблемы:
1. Запросы в SQLite.
Проблемы:
    некорректные запросы;
    слишком много параллельных запросов к одним и тем же данным;
    медленное получение данных.
Механизмы лечения:
    тестировать запросы заранее;
    сделать запросы следующими друг за другом;
    в одном запросе стараться запрашивать небольшой фрагмент данных.

2. Запросы в Elasticsearch (ES).
Проблемы:
    некорректно составленные запросы;
    дублирование данных;
    скорость загрузки данных.
Механизмы лечения:
    тестировать запросы заранее;
    выбрать заранее набор полей, которые будут составлять id документов в ES;
    загрузка одной записи одним HTTP-запросом происходит медленно, поэтому нужно посмотреть в сторону загрузки bulk-запросами (т.е. отправлять за один запрос несколько записей).

3. Сеть или падение одной из БД.
Одна из основных проблем современных систем — ненадёжность сетевой инфраструктуры. Возникает множество трудностей со связностью систем и потерей сетевых пакетов. Всё это обязательно нужно учитывать в своих системах.
Другая, но не менее частая проблема — выход дисков из строя. В один прекрасный момент любимая БД может накрыться медным тазом и заодно уложить все ваши ETL-процессы. Чтобы выжили хотя бы процессы, нужен механизм устойчивости к таким сбоям.
Проблемы:
    потеря сетевого соединения с БД. Для SQLite этой проблемы нет, так как подключение идёт к файлу с БД;
    побился файл БД SQLite;
    упал ES.
Механизмы лечения:
    в рамках ETL-процесса нужно заложить механизм повторов (retry-запросы) с увеличивающимся временем повторного запроса.
Обязательно закладывайте в системе увеличение времени между повторами, чтобы БД или сетевая инфраструктура после падения могла восстановить свою работоспособность.

4. Падение «механизма загрузки данных».
Проблемы:
    ошибка в коде;
    падение вслед за БД или сетью.
Механизмы лечения:
    покрывать код юнит- и интеграционными тестами;
    внедрять механизмы устойчивости к падениям;
    отслеживать, какие данные уже перегружены.
Основной упор в реализации механизма перегрузки данных необходимо сделать на способы восстановления работоспособности после падения. Чтобы решение получилось работающим, необходимо ответить на вопросы:
    Как сделать так, чтобы при падении процесс перегрузки начал с того места, где завершил работу до падения?
    Как не допустить дублей при загрузке данных в Elasticsearch?
    Как слишком не нагружать запросами SQLite?
    Как слишком не нагружать запросами Elasticsearch?